1) Почему на любом объекте можем вызвать метод getClass()?
    Метод getClass() является методом класса Object,
который является суперклассом для всех классов в Java.
Поскольку все классы наследуют от Object, каждый объект
имеет доступ к этому методу, что позволяет получить
информацию о классе, к которому принадлежит объект.

2) Почему на любом классе можем вызвать .class?
.class — это специальный синтаксический элемент в Java,
который предоставляет ссылку на объект Class,
представляющий данный класс. Он доступен для всех классов,
так как это часть языка, и его можно использовать для получения метаданных о классе,
таких как его имя, методы, поля и т.д.
Это работает на уровне компиляции, и компилятор всегда знает о классах.

3) В чём отличие динамического прокси от статического?
Статический прокси:
-Создается вручную и явно.
-Прокси-класс должен реализовывать интерфейс(ы),
которые он проксирует.
-Обычно используется для реализации паттерна проксирования "Прокси".
*Преимущества*
-Более простая отладка и понимание.
-Явная реализация методов.
*Недостатки*
-Требует создания нового класса для каждого прокси.
-Менее гибкий.

Динамический прокси:
-Создается во время выполнения с использованием java.lang.reflect.Proxy.
-Не требует создания конкретного класса прокси, вместо этого создается экземпляр прокси на основе интерфейса.
-Позволяет создавать прокси для любых объектов, реализующих интерфейс
*Преимущества*
-Гибкость и возможность создания прокси на лету
-Меньше кода, так как не нужно создавать новые классы.
*Недостатки*
-Сложнее отлаживать
-Может быть менее производительным из-за использования рефлексии

Приведите преимущества и недостатки.
4) Есть ли разница в инициализации класса через new и статический метод newInstance()?
new - это стандартный способ создания объекта. Он вызывает конструктор класса непосредственно и
выполняет все необходимые действия для инициализации объекта.

newInstance - этот метод является частью рефлексии и вызывает конструктор без параметров(если он существует).
Он может вызывать исключения, такие как InstantiationException, если класс не может быть инстанцирован
(например, если это абстрактный класс), или IllegalAccessException, если конструктор недоступен. Кроме того,
при использовании рефлексии могут возникать дополнительные накладные расходы по производительности.


5) Можно ли с помощью рефлексии изменить значения полей аннотации?
В Java аннотации являются синтаксическими метаданными, и их значения не могут быть изменены после компиляции.
Однако с помощью рефлексии можно получить доступ к полям аннотации и их значениям. Но попытка изменить их
значения приведет к исключению UnsupportedOperationException, так как аннотации являются неизменяемыми.
Таким образом, хотя вы можете получить доступ к значениям аннотаций через рефлексию, изменение этих значений невозможно.